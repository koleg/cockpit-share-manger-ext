import { SambaShare, AppSettings, FilesystemUsage } from '../types';

// In-memory representation of the server's filesystem for mocking
const mockFileSystem: { [key: string]: string } = {
  '/etc/samba/smb.conf': `
[global]
    workgroup = WORKGROUP
    security = user
`,
  '/etc/cockpit/zfs/shares/obmen.conf': `
[Обмен]
path = /srv/obmen
comment = Обмен
read only = no
browseable = yes
guest ok = no
cockpit quota = 10GB
`,
  '/etc/cockpit/zfs/shares/test.conf': `
[test]
path = /srv/test
comment = A test share
guest ok = yes
read only = yes
cockpit quota = 500MB
`,
  '/etc/cockpit/zfs/shares/smbpool1_test2.conf': `
[test2]
path = /media/samba/smbpool1/test2
read only = no
guest ok = no
browseable = yes
`,
  '/etc/cockpit/zfs/shares/smbpool1_test3.conf': `
[test3]
path = /media/samba/smbpool1/test3
read only = no
guest ok = no
browseable = yes
cockpit quota = 2GB
`,
  '/etc/cockpit/zfs/shares/smbpool1_test4.conf': `
[test4]
path = /media/samba/smbpool1/test4
read only = no
guest ok = no
browseable = yes
cockpit quota = 3G
`,
  '/etc/cockpit/zfs/shares/smbpool1_xxx.conf': `
[xxx]
path = /media/samba/smbpool1/xxx
read only = no
guest ok = no
browseable = yes
`,
  '/etc/samba/smm.cfg': `
shareConfigBasePath = /cockpit/zfs
defaultParentPath = /srv
defaultMountpointName = smbdatastore
theme = dark
`,
  '/etc/projid': `existing_project:100\nanother_project:101`,
  // These files will be dynamically generated by the mock _commitAndReload logic
  '/etc/cockpit/zfs/shares.conf': '',
  '/run/cockpit/zfs/shares.conf': '',
};


const mockCockpit = {
  spawn(command: string[], options?: any): any {
    console.log('[MOCK] cockpit.spawn:', command.join(' '), 'with options:', options);

    const promiseHandler = {
      _currentInputBuffer: [] as string[], // Stores chunks of input
      _inputEnded: false, // Flag to know if input(null) was called

      _doneCallback: (data: string, msg?: string) => {},
      _failCallback: (err: any, data?: any) => {},

      done(callback: (data: string, msg?: string) => void) {
        this._doneCallback = callback;
        return this;
      },
      fail(callback: (err: any, data?: any) => void) {
        this._failCallback = callback;
        return this;
      },
      input(data: string | null, encoding?: string) {
        if (data !== null) {
          this._currentInputBuffer.push(data);
        } else {
          this._inputEnded = true; // Signal end of input
        }
      },
      _execute() {
        // This logic is now synchronous to prevent race conditions in the UI.
        try {
          const { stdout, stderr, exit_status } = this._runCommand();
          if (exit_status === 0) {
            this._doneCallback(stdout);
          } else {
            this._failCallback({ message: stderr, exit_status });
          }
        } catch (e: any) {
          this._failCallback({ message: e.message, exit_status: -1 });
        }
      },
       _getMockSettings(): AppSettings {
            const settingsData = mockFileSystem[SETTINGS_FILE_PATH] || '';
            const settings: AppSettings = {
                shareConfigBasePath: DEFAULT_SHARE_CONFIG_BASE_PATH,
                defaultParentPath: DEFAULT_PARENT_PATH,
                defaultMountpointName: DEFAULT_MOUNTPOINT_NAME,
                theme: DEFAULT_THEME,
            };
            settingsData.split('\n').forEach(line => {
                const [key, value] = line.split('=').map(s => s.trim());
                if (key === 'shareConfigBasePath') settings.shareConfigBasePath = value;
                if (key === 'defaultParentPath') settings.defaultParentPath = value;
                if (key === 'defaultMountpointName') settings.defaultMountpointName = value;
                if (key === 'theme' && (value === 'dark' || value === 'light')) settings.theme = value;
            });
            return settings;
      },
      _runCommand() {
        const [cmd, ...args] = command;
        let stdout = '';
        let stderr = '';
        let exit_status = 0;

        if (cmd === '/bin/sh' && args[0] === '-c') {
          const shellCommand = args[1];
          // Handle complex commands in a more robust, "settings-aware" way
          if (shellCommand.includes('awk') && shellCommand.includes('/etc/samba/smb.conf')) {
                // MOCK for enableSambaConfig
                const settings = this._getMockSettings();
                const { MAIN_SHARES_CONFIG_FILE, RUN_MAIN_SHARES_CONFIG_FILE } = getSharePaths(settings);
                const uniqueComment = '# COCKPIT ZFS MANAGER';
                if (!mockFileSystem['/etc/samba/smb.conf'].includes(uniqueComment)) {
                    const contentToAdd = `\n\t${uniqueComment}\n\t# WARNING: DO NOT EDIT, AUTO-GENERATED CONFIGURATION\n\tinclude = ${MAIN_SHARES_CONFIG_FILE}\n\tinclude = ${RUN_MAIN_SHARES_CONFIG_FILE}\n`;
                    mockFileSystem['/etc/samba/smb.conf'] += contentToAdd;
                }
          } else if ((shellCommand.includes('sed -e') || shellCommand.includes('printf')) && shellCommand.includes('shares.conf')) {
                // MOCK for _commitAndReload (rebuilding the includes file)
                const settings = this._getMockSettings();
                const { SHARES_DIR, RUN_SHARES_DIR, MAIN_SHARES_CONFIG_FILE, RUN_MAIN_SHARES_CONFIG_FILE } = getSharePaths(settings);
                
                const rebuild = (dir: string, confFile: string) => {
                    // Ensure the target file exists, even if empty
                    mockFileSystem[confFile] = ''; 
                    const regex = new RegExp(`^${dir.replace(/\//g, '\\/')}\\/[^/]+\\.conf$`);
                    const includes = Object.keys(mockFileSystem)
                        .filter(file => regex.test(file)).sort().map(file => `include = ${file}`);
                    mockFileSystem[confFile] = `# COCKPIT ZFS MANAGER\n# WARNING: DO NOT EDIT, AUTO-GENERATED CONFIGURATION\n${includes.join('\n')}`;
                };
                
                rebuild(SHARES_DIR, MAIN_SHARES_CONFIG_FILE);
                rebuild(RUN_SHARES_DIR, RUN_MAIN_SHARES_CONFIG_FILE);

          } else if (shellCommand.startsWith('cat ')) {
            const fileToCat = shellCommand.replace('cat ', '').trim();
            if (fileToCat.includes('*.conf')) {
                const pattern = fileToCat.split(' ')[0]; 
                const dir = pattern.substring(0, pattern.lastIndexOf('/'));
                const regex = new RegExp(`^${dir.replace(/\//g, '\\/')}\\/[^/]+\\.conf$`);
                
                let content = '';
                let filesFound = false;
                Object.keys(mockFileSystem).forEach(file => {
                    if (regex.test(file)) {
                        content += mockFileSystem[file] + '\n\n';
                        filesFound = true;
                    }
                });
    
                if (filesFound) {
                  stdout = content;
                } else {
                    // This is the expected behavior for a new, empty setup.
                    // It should return exit code 0 and empty stdout.
                    stdout = '';
                }
            } else if (mockFileSystem.hasOwnProperty(fileToCat)) {
                stdout = mockFileSystem[fileToCat];
            } else {
                // For other files, if they don't exist, it's an error.
                exit_status = 1;
                stderr = `cat: ${fileToCat}: No such file or directory`;
            }
          } else if (shellCommand.includes('find') && shellCommand.includes('-exec cat')) {
            // MOCK for robust getShares
            const settings = this._getMockSettings();
            const { SHARES_DIR } = getSharePaths(settings);
            const regex = new RegExp(`^${SHARES_DIR.replace(/\//g, '\\/')}\\/[^/]+\\.conf$`);
            let content = '';
            Object.keys(mockFileSystem).forEach(file => {
                if (regex.test(file)) {
                    content += mockFileSystem[file] + '\n\n';
                }
            });
            stdout = content;
          } else if (shellCommand.includes('grep -q')) {
            const settings = this._getMockSettings();
            const { MAIN_SHARES_CONFIG_FILE } = getSharePaths(settings);
            const fileContent = mockFileSystem['/etc/samba/smb.conf'] || '';
            
            if (shellCommand.includes(`include = ${MAIN_SHARES_CONFIG_FILE}`)) {
                 exit_status = fileContent.includes(`include = ${MAIN_SHARES_CONFIG_FILE}`) ? 0 : 1;
            } else if (shellCommand.includes("COCKPIT ZFS MANAGER")) {
                exit_status = fileContent.includes('# COCKPIT ZFS MANAGER') ? 0 : 1;
            } else {
                exit_status = 1; // Unrecognized grep command
            }
            stdout = exit_status === 0 ? 'true\n' : 'false\n';
          } else if (shellCommand.includes('>> /etc/projid')) {
              const contentToAdd = shellCommand.match(/'(.*?)'/)?.[1];
              if (contentToAdd) {
                  mockFileSystem['/etc/projid'] = (mockFileSystem['/etc/projid'] || '') + `\n${contentToAdd}`;
              }
          } else if (shellCommand.includes('mkdir -p')) {
              console.log('[MOCK] Ensured directories exist.');
              stdout = 'Skipped'; 
          }
        } else if (cmd === 'rm') {
          const filePath = args[0];
          if (mockFileSystem.hasOwnProperty(filePath)) {
            delete mockFileSystem[filePath];
          } else {
            exit_status = 1;
            stderr = `rm: cannot remove '${filePath}': No such file or directory`;
          }
        } else if (cmd === 'tee') {
          if (this._inputEnded && this._currentInputBuffer.length > 0) {
            const filePath = args[0];
            mockFileSystem[filePath] = this._currentInputBuffer.join(''); // Join all buffered chunks
          } else {
            exit_status = 1;
            stderr = 'tee: missing input or input stream not properly closed';
          }
        } else if (cmd === 'repquota') {
            const mockProjectName1 = 'srv_obmen';
            const mockProjectName2 = 'srv_test';
            stdout = `Project,SpaceStatus,FileStatus,SpaceUsed,SpaceSoftLimit,SpaceHardLimit,SpaceGrace,FileUsed,FileSoftLimit,FileHardLimit,FileGrace
#0,ok,ok,20K,0K,0K,,2,0,0,
${mockProjectName1},ok,ok,5.2G,0K,10G,,150,0,0,
${mockProjectName2},ok,ok,250M,0K,500M,,42,0,0,
`;
        } else if (cmd === 'df') {
            const settings = this._getMockSettings();
            const pathToCheck = `${settings.defaultParentPath}/${settings.defaultMountpointName}`.replace(/\/+/g, '/');
            if (args.includes(pathToCheck)) {
                stdout = ` Size Avail Used Use% Source\n 1900000 1700000 108600 6% /dev/mapper/mock-vg-lv`;
            } else {
                exit_status = 1;
                stderr = `df: ${args[args.length - 1]}: No such file or directory`;
            }
        } else if (['mkdir', 'chmod', 'chattr', 'smbcontrol', 'find'].includes(cmd)) {
           // No-op for mock, always succeeds.
           console.log(`[MOCK] Executed ${cmd} with args:`, args);
        } else if (cmd === 'setquota') {
            if (args.length >= 7 && args[0] === '-u') {
                const userName = args[1];
                const hardBlocks = args[3];
                console.log(`[MOCK] USER Quota applied for user '${userName}' with hard limit: ${hardBlocks}KB on all mounted filesystems.`);
            } else if (args.length >= 8 && args[0] === '-P') {
                const projectName = args[1];
                const hardBlocks = args[3];
                const filesystem = args[7];
                console.log(`[MOCK] PROJECT Quota applied for project '${projectName}' with hard limit: ${hardBlocks}KB on filesystem '${filesystem}'.`);
            } else {
                exit_status = 1;
                stderr = "setquota: missing or invalid arguments";
            }
        } else {
          exit_status = 127;
          stderr = `command not found: ${cmd}`;
        }
        return { stdout, stderr, exit_status };
      },
    };

    promiseHandler._execute();
    return promiseHandler;
  },
};

const cockpit = (window as any).cockpit || mockCockpit;

const DEFAULT_SHARE_CONFIG_BASE_PATH = '/cockpit/zfs';
const DEFAULT_MAIN_SHARES_CONFIG_FILE_NAME = 'shares.conf';
const DEFAULT_PARENT_PATH = '/media/samba';
const DEFAULT_MOUNTPOINT_NAME = 'smbdatastore';
const DEFAULT_THEME: 'dark' | 'light' = 'dark';

const SETTINGS_FILE_PATH = '/etc/samba/smm.cfg';

const getSharePaths = (settings: AppSettings) => {
    const SHARES_DIR = `/etc${settings.shareConfigBasePath}/shares`;
    const RUN_SHARES_DIR = `/run${settings.shareConfigBasePath}/shares`;
    const MAIN_SHARES_CONFIG_FILE = `/etc${settings.shareConfigBasePath}/${DEFAULT_MAIN_SHARES_CONFIG_FILE_NAME}`;
    const RUN_MAIN_SHARES_CONFIG_FILE = `/run${settings.shareConfigBasePath}/${DEFAULT_MAIN_SHARES_CONFIG_FILE_NAME}`;
    return { SHARES_DIR, RUN_SHARES_DIR, MAIN_SHARES_CONFIG_FILE, RUN_MAIN_SHARES_CONFIG_FILE };
};

function parseSmbConf(data: string): SambaShare[] {
    const shares: SambaShare[] = [];
    const lines = data.split('\n');
    let currentShareData: Omit<SambaShare, 'id'> | null = null;
    let advancedSettingsBuffer: string[] = [];

    const commitCurrentShare = () => {
        if (currentShareData && currentShareData.path) {
            currentShareData.advancedSettings = advancedSettingsBuffer.join('\n').trim();
            // Create a stable, unique, and unambiguous ID from name and path to use as a React key.
            // Using JSON.stringify prevents issues with special characters like '|' in names or paths.
            const uniqueId = JSON.stringify([currentShareData.name, currentShareData.path]);
            shares.push({ ...currentShareData, id: uniqueId });
        }
    };

    for (const line of lines) {
        const trimmedLine = line.trim();
        if (trimmedLine === '' || trimmedLine.startsWith('#') || trimmedLine.startsWith(';')) {
            continue;
        }

        if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
            commitCurrentShare(); // Commit the previous share before starting a new one
            const name = trimmedLine.substring(1, trimmedLine.length - 1);
            currentShareData = {
                name,
                path: '',
                comment: '',
                guestOk: false,
                readOnly: true,
                browsable: true,
                quota: '',
            };
            advancedSettingsBuffer = [];
        } else if (currentShareData && trimmedLine.includes('=')) {
            const parts = trimmedLine.split('=').map(p => p.trim());
            const key = parts[0].toLowerCase();
            const value = parts.slice(1).join('=').trim();
            
            switch(key) {
                case 'path': currentShareData.path = value; break;
                case 'comment': currentShareData.comment = value; break;
                case 'guest ok': currentShareData.guestOk = ['yes', 'true'].includes(value.toLowerCase()); break;
                case 'read only': currentShareData.readOnly = ['yes', 'true'].includes(value.toLowerCase()); break;
                case 'browsable': case 'browseable': currentShareData.browsable = ['yes', 'true'].includes(value.toLowerCase()); break;
                case 'cockpit quota': currentShareData.quota = value; break;
                default: advancedSettingsBuffer.push(line.trim());
            }
        }
    }

    commitCurrentShare(); // Commit the last share in the file
    
    return shares;
}

function serializeSingleShare(share: SambaShare): string {
    const indent = '        '; // 8 spaces
    const lines: string[] = [];

    // Header
    lines.push(`# COCKPIT ZFS MANAGER`);
    lines.push(`# WARNING: DO NOT EDIT, AUTO-GENERATED CONFIGURATION`);

    // Share section
    lines.push(`[${share.name}]`);

    // Basic parameters with indentation, matching user's example order
    lines.push(`${indent}path = ${share.path}`);
    if (share.comment) {
        lines.push(`${indent}comment = ${share.comment}`);
    }
    lines.push(`${indent}browseable = ${share.browsable ? 'yes' : 'no'}`);
    lines.push(`${indent}read only = ${share.readOnly ? 'yes' : 'no'}`);
    lines.push(`${indent}guest ok = ${share.guestOk ? 'yes' : 'no'}`);
    if (share.quota) {
        lines.push(`${indent}cockpit quota = ${share.quota}`);
    }

    // Advanced settings section
    if (share.advancedSettings && share.advancedSettings.trim()) {
        lines.push(``); // Blank line separator
        lines.push(`# ADD ADDITIONAL CONFIGURATION HERE`);
        // The advanced settings string might contain multiple lines. Each line needs to be indented.
        const advancedLines = share.advancedSettings.trim().split('\n').map(line => `${indent}${line.trim()}`);
        lines.push(...advancedLines);
    }

    // Add a trailing newline for POSIX compliance and better file formatting.
    return lines.join('\n') + '\n';
}

const convertQuotaToKB = (quotaString: string): number | null => {
    const match = quotaString.match(/^(\d+)\s*(K|M|G|T|P)?B?$/i);
    if (!match) return null;
    const value = parseInt(match[1], 10);
    const unit = match[2]?.toUpperCase();
    switch (unit) {
        case 'K': case undefined: return value;
        case 'M': return value * 1024;
        case 'G': return value * 1024 * 1024;
        case 'T': return value * 1024 * 1024 * 1024;
        case 'P': return value * 1024 * 1024 * 1024 * 1024;
        default: return null;
    }
};

// A single, robust function to generate the project/file name from the share path.
const getProjectNameFromPath = (path: string): string => {
    const pathParts = path.split('/').filter(p => p);
    if (pathParts.length === 0) {
        return '_root_share'; // Edge case for path "/"
    }
    if (pathParts.length >= 2) {
        const shareFolderName = pathParts[pathParts.length - 1];
        const mountpointName = pathParts[pathParts.length - 2];
        return `${mountpointName}_${shareFolderName}`;
    }
    // Consistent fallback for shallow paths like "/data" -> becomes "_data"
    return `_${pathParts.join('_')}`;
};

const getShareFilePath = (share: SambaShare, configBasePath: string): string => {
    const projectName = getProjectNameFromPath(share.path);
    return `${configBasePath}/${projectName}.conf`;
};

const getProjectName = (share: SambaShare): string => {
    return getProjectNameFromPath(share.path);
};

export const sambaService = {
  getSettings: async (): Promise<AppSettings> => {
    const command = ['/bin/sh', '-c', `cat ${SETTINGS_FILE_PATH} 2>/dev/null`];
    try {
      const data = await new Promise<string>((resolve, reject) => {
        cockpit.spawn(command, { err: 'out' })
          .done((res: string) => resolve(res))
          .fail(() => resolve('')); // Always resolve, defaults will be used
      });

      const settings: AppSettings = {
        shareConfigBasePath: DEFAULT_SHARE_CONFIG_BASE_PATH,
        defaultParentPath: DEFAULT_PARENT_PATH,
        defaultMountpointName: DEFAULT_MOUNTPOINT_NAME,
        theme: DEFAULT_THEME,
      };

      data.split('\n').forEach(line => {
        const [key, value] = line.split('=').map(s => s.trim());
        if (key === 'shareConfigBasePath') settings.shareConfigBasePath = value;
        if (key === 'defaultParentPath') settings.defaultParentPath = value;
        if (key === 'defaultMountpointName') settings.defaultMountpointName = value;
        if (key === 'theme' && (value === 'dark' || value === 'light')) settings.theme = value;
      });
      return settings;
    } catch (error) {
      console.error('Error fetching settings, using defaults:', error);
      return {
        shareConfigBasePath: DEFAULT_SHARE_CONFIG_BASE_PATH,
        defaultParentPath: DEFAULT_PARENT_PATH,
        defaultMountpointName: DEFAULT_MOUNTPOINT_NAME,
        theme: DEFAULT_THEME,
      };
    }
  },

  saveSettings: async (settings: AppSettings): Promise<void> => {
    const fileContent = `shareConfigBasePath = ${settings.shareConfigBasePath}\ndefaultParentPath = ${settings.defaultParentPath}\ndefaultMountpointName = ${settings.defaultMountpointName}\ntheme = ${settings.theme}\n`;
    const command = ['tee', SETTINGS_FILE_PATH];
    
    return new Promise((resolve, reject) => {
        const process = cockpit.spawn(command, { superuser: 'require', err: 'out' });
        process.input(fileContent, 'utf-8');
        process.input(null);
        process.done(() => resolve())
        .fail((err: any) => reject(new Error(`Failed to save settings: ${err.message}`)));
    });
  },

  getFilesystemUsage: async (settings: AppSettings): Promise<FilesystemUsage | null> => {
    const pathToCheck = `${settings.defaultParentPath}/${settings.defaultMountpointName}`.replace(/\/+/g, '/');
    const command = ['df', '--output=size,avail,used,pcent,source', pathToCheck];

    try {
        const data = await new Promise<string>((resolve, reject) => {
            cockpit.spawn(command, { err: 'out' })
                .done((res: string) => resolve(res))
                .fail((err: any) => reject(new Error(err.message)));
        });

        const lines = data.trim().split('\n');
        if (lines.length < 2) {
            throw new Error('Unexpected output from df command.');
        }

        // Skip header line, split the data line by whitespace
        const values = lines[1].trim().split(/\s+/);
        if (values.length < 5) {
            throw new Error('Could not parse df output.');
        }

        return {
            size: values[0],
            available: values[1],
            used: values[2],
            usedPercent: values[3],
            filesystem: values[4],
            mountpoint: pathToCheck,
        };
    } catch (error) {
        console.warn(`Could not fetch filesystem usage for ${pathToCheck}:`, error);
        return null;
    }
  },

  _getQuotaUsage: async (): Promise<Map<string, { used: string; hard: string }>> => {
    const usageMap = new Map<string, { used: string; hard: string }>();
    try {
        const command = ['repquota', '-aP', '-C', '-s', '-O', 'csv'];
        const csvData = await new Promise<string>((resolve, reject) => {
            cockpit.spawn(command, { superuser: 'require', err: 'out' })
                .done((data: string) => resolve(data))
                .fail((err: any) => reject(new Error(`repquota failed: ${err.message}`)));
        });

        if (!csvData) return usageMap;
        
        const lines = csvData.trim().split('\n');
        if (lines.length < 2) {
            return usageMap; // No data or only header
        }

        const header = lines[0].split(',');
        const projectIndex = header.indexOf('Project');
        const usedIndex = header.indexOf('SpaceUsed');
        const hardIndex = header.indexOf('SpaceHardLimit');

        if (projectIndex === -1 || usedIndex === -1 || hardIndex === -1) {
            throw new Error('Could not find required columns (Project, SpaceUsed, SpaceHardLimit) in repquota CSV output.');
        }

        for (let i = 1; i < lines.length; i++) {
            const values = lines[i].split(',');
            if (values.length > Math.max(projectIndex, usedIndex, hardIndex)) {
                const projectName = values[projectIndex];
                if (projectName && projectName !== '#0') {
                    const used = values[usedIndex] || '0K';
                    const hard = values[hardIndex] || '0K';
                    usageMap.set(projectName, { used, hard });
                }
            }
        }
    } catch (error) {
        console.warn("Could not fetch or parse quota usage:", error);
    }
    return usageMap;
  },

  getShares: async (): Promise<SambaShare[]> => {
    const settings = await sambaService.getSettings();
    const { SHARES_DIR } = getSharePaths(settings);
    // Use a robust `find` command that gracefully handles an empty directory
    const command = ['/bin/sh', '-c', `find ${SHARES_DIR} -maxdepth 1 -type f -name '*.conf' -exec cat {} + 2>/dev/null`];

    const sharesPromise = new Promise<SambaShare[]>((resolve, reject) => {
        cockpit.spawn(command, { err: 'out' })
            .done((data: string) => resolve(parseSmbConf(data)))
            .fail((err: any) => {
                // The `find` command is very reliable, but we still handle failure just in case.
                reject(new Error('Failed to read shares configuration.'));
            });
    });

    const [shares, quotaUsage] = await Promise.all([sharesPromise, sambaService._getQuotaUsage()]);
    
    const enrichedShares = shares.map(share => {
        const projectName = getProjectName(share);
        const usage = quotaUsage.get(projectName);

        if (usage) {
            const finalQuota = usage.hard !== '0K' ? usage.hard : share.quota;
            return {
                ...share,
                used: usage.used,
                quota: finalQuota,
            };
        }
        return share;
    });

    return enrichedShares;
  },

  _commitAndReload: async (): Promise<void> => {
      const settings = await sambaService.getSettings();
      const { SHARES_DIR, RUN_SHARES_DIR, MAIN_SHARES_CONFIG_FILE, RUN_MAIN_SHARES_CONFIG_FILE } = getSharePaths(settings);

      // FIX: Ensure the volatile /run directory exists before trying to write into it.
      await new Promise<void>((resolve, reject) => {
        cockpit.spawn(['mkdir', '-p', RUN_SHARES_DIR], { superuser: 'require', err: 'out' })
            .done(() => resolve())
            .fail((err: any) => reject(new Error(`Failed to create runtime directory ${RUN_SHARES_DIR}: ${err.message}`)));
      });

      // Using printf is more portable for handling newlines than echo.
      // A sort is added to ensure the include file is deterministic.
      const header = '# COCKPIT ZFS MANAGER\n# WARNING: DO NOT EDIT, AUTO-GENERATED CONFIGURATION';
      const rebuildEtcCmd = `printf '%s\\n' '${header}' > ${MAIN_SHARES_CONFIG_FILE} && find ${SHARES_DIR} -maxdepth 1 -type f -name '*.conf' 2>/dev/null | sort | sed -e 's/^/include = /' >> ${MAIN_SHARES_CONFIG_FILE}`;
      const rebuildRunCmd = `printf '%s\\n' '${header}' > ${RUN_MAIN_SHARES_CONFIG_FILE} && find ${RUN_SHARES_DIR} -maxdepth 1 -type f -name '*.conf' 2>/dev/null | sort | sed -e 's/^/include = /' >> ${RUN_MAIN_SHARES_CONFIG_FILE}`;

      const rebuildIncludesCommand = ["/bin/sh", "-c", `${rebuildEtcCmd} && ${rebuildRunCmd}`];
      const reloadSambaCommand = ['smbcontrol', 'all', 'reload-config'];

      return new Promise((resolve, reject) => {
          cockpit.spawn(rebuildIncludesCommand, { err: "out", superuser: "require" })
              .done(() => {
                  cockpit.spawn(reloadSambaCommand, { superuser: 'require', err: 'out' })
                      .done(() => resolve())
                      .fail((err: any) => reject(new Error('Config saved, but failed to reload Samba.')));
              })
              .fail((err: any) => reject(new Error("Failed to rebuild main shares file.")));
      });
  },
  
  _writeShareFile: async (share: SambaShare): Promise<void> => {
      const settings = await sambaService.getSettings();
      const { SHARES_DIR } = getSharePaths(settings);
      const fileContent = serializeSingleShare(share);
      const filePath = getShareFilePath(share, SHARES_DIR);
      
      return new Promise((resolve, reject) => {
          cockpit.spawn(['mkdir', '-p', SHARES_DIR], { superuser: 'require' })
              .done(() => {
                  const process = cockpit.spawn(['tee', filePath], { superuser: 'require', err: 'out' });
                  process.input(fileContent, 'utf-8');
                  process.input(null);
                  process.done(() => resolve())
                  .fail((err: any) => reject(new Error(`Failed to write share file for "${share.name}".`)));
              })
              .fail((err: any) => reject(new Error('Failed to create shares directory.')));
      });
  },

  _applyQuota: async (share: SambaShare, settings: AppSettings): Promise<void> => {
      // Handles applying a new quota or updating/removing an existing one for a project.
      const projectName = getProjectName(share);
      
      // If quota is an empty string or not present, we set limits to 0, effectively removing it.
      const quotaInKB = (share.quota && share.quota.trim()) ? convertQuotaToKB(share.quota) : 0;

      // convertQuotaToKB returns null on invalid format.
      if (quotaInKB === null) {
          console.warn(`Invalid quota format for project '${projectName}': '${share.quota}'. Skipping quota update.`);
          return;
      }
      
      // The filesystem path where quotas are applied.
      const filesystemPath = `${settings.defaultParentPath}/${settings.defaultMountpointName}`.replace(/\/+/g, '/');

      const quotaCommand = ['setquota', '-P', projectName, '0', quotaInKB.toString(), '0', '0', filesystemPath];
      
      return new Promise((resolve) => {
          cockpit.spawn(quotaCommand, { superuser: 'require', err: 'out' })
              .done(() => {
                  console.log(`Successfully applied quota for project '${projectName}'.`);
                  resolve();
              })
              .fail((err: any) => {
                  console.error(`Failed to apply quota for project '${projectName}':`, err.message);
                  resolve(); // Log error but don't block the UI flow.
              });
      });
  },

  _ensureDirectoryAndPermissions: async (path: string): Promise<void> => {
      await new Promise<void>((resolve, reject) => {
          cockpit.spawn(['mkdir', '-p', path], { superuser: 'require', err: 'out' })
              .done(() => resolve())
              .fail((err: any) => reject(new Error(`Failed to create directory ${path}: ${err.message}`)));
      });
      await new Promise<void>((resolve, reject) => {
          cockpit.spawn(['chmod', '0777', path], { superuser: 'require', err: 'out' })
              .done(() => resolve())
              .fail((err: any) => reject(new Error(`Failed to set permissions on ${path}: ${err.message}`)));
      });
  },

  _getOrCreateProjectId: async (projectName: string): Promise<number> => {
    const projidContent = await new Promise<string>((resolve, reject) => {
        cockpit.spawn(['/bin/sh', '-c', 'cat /etc/projid 2>/dev/null'])
            .done((data: string) => resolve(data))
            .fail((err: any) => reject(new Error(`Failed to read /etc/projid: ${err.message}`)));
    });

    const projects = new Map<string, number>();
    let maxId = 99; // Start new IDs from 100

    projidContent.split('\n').forEach(line => {
        const trimmed = line.trim();
        if (trimmed && !trimmed.startsWith('#')) {
            const [name, idStr] = trimmed.split(':');
            const id = parseInt(idStr, 10);
            if (name && !isNaN(id)) {
                projects.set(name, id);
                if (id > maxId) maxId = id;
            }
        }
    });

    if (projects.has(projectName)) {
        return projects.get(projectName)!;
    }

    const newProjectId = maxId + 1;
    const newLine = `${projectName}:${newProjectId}`;
    
    await new Promise<void>((resolve, reject) => {
        const command = ['/bin/sh', '-c', `echo '${newLine}' >> /etc/projid`];
        cockpit.spawn(command, { superuser: 'require', err: 'out' })
            .done(() => resolve())
            .fail((err: any) => reject(new Error(`Failed to write to /etc/projid: ${err.message}`)));
    });

    return newProjectId;
  },

  _applyProjectAttribute: async (projectId: number, path: string): Promise<void> => {
      const commandForDirs = ['find', path, '-type', 'd', '-exec', 'chattr', '+P', '-p', projectId.toString(), '{}', '+'];
      await new Promise<void>((resolve, reject) => {
          cockpit.spawn(commandForDirs, { superuser: 'require', err: 'out' })
              .done(() => resolve())
              .fail((err: any) => reject(new Error(`Failed to apply project attribute to directories in ${path}: ${err.message}`)));
      });

      const commandForFiles = ['find', path, '-type', 'f', '-exec', 'chattr', '-p', projectId.toString(), '{}', '+'];
      await new Promise<void>((resolve, reject) => {
          cockpit.spawn(commandForFiles, { superuser: 'require', err: 'out' })
              .done(() => resolve())
              .fail((err: any) => reject(new Error(`Failed to apply project attribute to files in ${path}: ${err.message}`)));
      });
  },

  addShare: async (shareData: Omit<SambaShare, 'id'>): Promise<SambaShare[]> => {
    const currentShares = await sambaService.getShares();
    
    if (currentShares.find(s => s.name === shareData.name)) {
        throw new Error(`A share with the name "${shareData.name}" already exists.`);
    }
    if (currentShares.find(s => s.path === shareData.path)) {
        throw new Error(`A share with the path "${shareData.path}" already exists.`);
    }

    // Use the same robust key generation as the parser
    const newShareId = JSON.stringify([shareData.name, shareData.path]);
    const newShare: SambaShare = { ...shareData, id: newShareId };
    
    await sambaService._ensureDirectoryAndPermissions(newShare.path);
    const projectName = getProjectName(newShare);
    const projectId = await sambaService._getOrCreateProjectId(projectName);
    await sambaService._applyProjectAttribute(projectId, newShare.path);

    await sambaService._writeShareFile(newShare);
    await sambaService._commitAndReload();
    const settings = await sambaService.getSettings();
    await sambaService._applyQuota(newShare, settings);
    return sambaService.getShares();
  },

  updateShare: async (updatedShare: SambaShare): Promise<SambaShare[]> => {
    const settings = await sambaService.getSettings();
    const { SHARES_DIR } = getSharePaths(settings);

    const currentShares = await sambaService.getShares();
    const originalShare = currentShares.find(s => s.id === updatedShare.id);
    if (!originalShare) throw new Error('Share not found for update.');
    
    const nameChanged = originalShare.name !== updatedShare.name;
    const pathChanged = originalShare.path !== updatedShare.path;

    if (nameChanged && currentShares.find(s => s.name === updatedShare.name)) {
         throw new Error(`A share with the name "${updatedShare.name}" already exists.`);
    }
    
    if (pathChanged && currentShares.find(s => s.path === updatedShare.path)) {
        throw new Error(`A share with the path "${updatedShare.path}" is already in use by another share.`);
    }

    if (pathChanged) {
        await sambaService._ensureDirectoryAndPermissions(updatedShare.path);
        const newProjectName = getProjectName(updatedShare);
        const projectId = await sambaService._getOrCreateProjectId(newProjectName);
        await sambaService._applyProjectAttribute(projectId, updatedShare.path);

        // If the path changed, the project name also changes. We must remove the quota from the old project.
        if (originalShare.quota) {
            const oldProjectName = getProjectName(originalShare);
            const filesystemPath = `${settings.defaultParentPath}/${settings.defaultMountpointName}`.replace(/\/+/g, '/');
            // Spawn a command to set the old project's quota to 0. We don't need to wait for it.
            cockpit.spawn(['setquota', '-P', oldProjectName, '0', '0', '0', '0', filesystemPath], { superuser: 'require', err: 'out' });
            console.log(`Removing quota from old project '${oldProjectName}' due to path change.`);
        }
    }

    await sambaService._writeShareFile(updatedShare);
    
    const newFilePath = getShareFilePath(updatedShare, SHARES_DIR);
    const oldFilePathFromNewLogic = getShareFilePath(originalShare, SHARES_DIR);

    const getLegacyShareFilePath = (share: SambaShare, configBasePath: string): string => {
        const pathParts = share.path.split('/').filter(p => p);
        if (pathParts.length >= 2) {
            const shareFolderName = pathParts[pathParts.length - 1];
            const mountpointName = pathParts[pathParts.length - 2];
            return `${configBasePath}/${mountpointName}-${shareFolderName}.conf`;
        }
        return `${configBasePath}/${share.name}.conf`;
    };
    const legacyFilePath = getLegacyShareFilePath(originalShare, SHARES_DIR);

    const cleanupFile = (filePath: string) => new Promise<void>(resolve => {
        cockpit.spawn(['rm', filePath], { superuser: 'require', err: 'out' }).always(() => resolve());
    });

    if (oldFilePathFromNewLogic !== newFilePath) await cleanupFile(oldFilePathFromNewLogic);
    if (legacyFilePath !== newFilePath) await cleanupFile(legacyFilePath);
    
    await sambaService._commitAndReload();
    await sambaService._applyQuota(updatedShare, settings);
    return sambaService.getShares();
  },

  deleteShare: async (shareId: string): Promise<SambaShare[]> => {
    const settings = await sambaService.getSettings();
    const { SHARES_DIR } = getSharePaths(settings);

    const currentShares = await sambaService.getShares();
    const shareToDelete = currentShares.find(s => s.id === shareId);

    if (!shareToDelete) {
        await sambaService._commitAndReload();
        return sambaService.getShares();
    }

    const cleanupFile = (filePath: string) => new Promise<void>(resolve => {
        cockpit.spawn(['rm', filePath], { superuser: 'require', err: 'out' }).always(() => resolve());
    });
    
    const newFilePath = getShareFilePath(shareToDelete, SHARES_DIR);
    await cleanupFile(newFilePath);

    const getLegacyShareFilePath = (share: SambaShare, configBasePath: string): string => {
        const pathParts = share.path.split('/').filter(p => p);
        if (pathParts.length >= 2) {
            const shareFolderName = pathParts[pathParts.length - 1];
            const mountpointName = pathParts[pathParts.length - 2];
            return `${configBasePath}/${mountpointName}-${shareFolderName}.conf`;
        }
        return `${configBasePath}/${share.name}.conf`;
    };
    const legacyFilePath = getLegacyShareFilePath(shareToDelete, SHARES_DIR);

    if (legacyFilePath !== newFilePath) await cleanupFile(legacyFilePath);

    await sambaService._commitAndReload();

    // Remove project quota if it was set
    if (shareToDelete.quota) {
        const projectName = getProjectName(shareToDelete);
        const filesystemPath = `${settings.defaultParentPath}/${settings.defaultMountpointName}`.replace(/\/+/g, '/');
        cockpit.spawn(['setquota', '-P', projectName, '0', '0', '0', '0', filesystemPath], { superuser: 'require', err: 'out' });
        console.log(`Removing quota from project '${projectName}' for deleted share.`);
    }
    return sambaService.getShares();
  },

  checkSambaConfig: async (): Promise<boolean> => {
      const settings = await sambaService.getSettings();
      const { MAIN_SHARES_CONFIG_FILE } = getSharePaths(settings);
      const command = ["/bin/sh", "-c", `grep -q 'include = ${MAIN_SHARES_CONFIG_FILE}' /etc/samba/smb.conf && echo true || echo false`];
      return new Promise((resolve) => {
          cockpit.spawn(command, { err: 'out' })
              .done((data: string) => resolve(data.trim() === 'true'))
              .fail(() => resolve(false));
      });
  },

  createConfigDirectories: async (): Promise<void> => {
    const settings = await sambaService.getSettings();
    const basePath = `/etc${settings.shareConfigBasePath}`;
    const sharesPath = `${basePath}/shares`;
    const snapshotsPath = `${basePath}/snapshots`; // Assuming snapshots is a sibling of shares

    // The `mkdir -p` command is idempotent. It creates directories if they don't exist
    // and does nothing (without error) if they already exist. This is safer and simpler.
    const command = ["/bin/mkdir", "-p", sharesPath, snapshotsPath];
    return new Promise((resolve, reject) => {
        cockpit.spawn(command, { superuser: 'require', err: 'out' })
            .done(() => resolve())
            .fail((err: any) => reject(new Error("Failed to create necessary configuration directories.")));
    });
  },

  enableSambaConfig: async (): Promise<void> => {
      const settings = await sambaService.getSettings();
      const { MAIN_SHARES_CONFIG_FILE, RUN_MAIN_SHARES_CONFIG_FILE } = getSharePaths(settings);

      const uniqueComment = '# COCKPIT ZFS MANAGER';
      
      const isAlreadyConfigured = await new Promise<boolean>(resolve => {
        cockpit.spawn(['/bin/sh', '-c', `grep -q "${uniqueComment}" /etc/samba/smb.conf`])
            .done(() => resolve(true))
            .fail(() => resolve(false));
      });

      if (isAlreadyConfigured) {
          console.log("Samba config already contains manager includes. Skipping.");
          return Promise.resolve();
      }

      const awkInsert = `\n\t${uniqueComment}\n\t# WARNING: DO NOT EDIT, AUTO-GENERATED CONFIGURATION\n\tinclude = ${MAIN_SHARES_CONFIG_FILE}\n\tinclude = ${RUN_MAIN_SHARES_CONFIG_FILE}\n`;
      // FIX: The backslash in the awk regex `/^\\[/` was not properly escaped for the JavaScript template literal.
      // It should be `/^\\\[/` to ensure a literal backslash is passed to the shell, forming a valid awk regex.
      const command = ["/bin/sh", "-c", `[ -s /etc/samba/smb.conf ] && /usr/bin/awk -v k='${awkInsert}' '($1=="[global]"||x&&/^\\\[/)&&!(x=!x){print k} END{if(x)print k}1' /etc/samba/smb.conf > /etc/samba/smb.tmp && /bin/mv -f /etc/samba/smb.tmp /etc/samba/smb.conf || { echo '/etc/samba/smb.conf file does not exist or is empty.' ; exit 1; }`];
      
      return new Promise((resolve, reject) => {
          cockpit.spawn(command, { superuser: 'require', err: 'out' })
              .done(() => resolve())
              .fail((err: any) => reject(new Error("Failed to update smb.conf. Please do it manually.")));
      });
  }
};